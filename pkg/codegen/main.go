// Package main provides a code generator for CloudEventHeader field accessors.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"reflect"
	"strings"
	"text/template"

	"github.com/DIMO-Network/cloudevent"
	"github.com/DIMO-Network/model-garage/pkg/codegen"
)

// CloudeventHeadersToColumnMap is a map of cloudevent header json fields to Clickhouse columns.
var CloudeventHeadersToColumnMap = map[string]struct{}{
	"subject":         {},
	"time":            {},
	"type":            {},
	"id":              {},
	"source":          {},
	"producer":        {},
	"datacontenttype": {},
	"dataversion":     {},
	"extras":          {},
}

// FieldInfo contains information about a field in the CloudEventHeader.
type FieldInfo struct {
	// FieldName is the name of the field in the CloudEventHeader struct.
	FieldName string
	// JSONName is the name of the field in the JSON tag.
	JSONName string
	// GoType is the type of the field as a string.
	GoType reflect.Type
	// Kind is the kind of the field.
	Kind string
	// Options contains the options for the field generation.
	Options Options
}

// TemplateData contains all the data needed for template generation.
type TemplateData struct {
	// NonColumnFields is a list of fields that are not columns in Clickhouse.
	NonColumnFields []FieldInfo
}

func main() {
	// Parse command line arguments
	outputFile := flag.String("output", "pkg/clickhouse/field_accessors_gen.go", "Output file path for generated code")
	flag.Parse()

	// Get information about CloudEventHeader fields
	headerType := reflect.TypeOf(cloudevent.CloudEventHeader{})

	var nonColumnFields []FieldInfo

	for i := 0; i < headerType.NumField(); i++ {
		field := headerType.Field(i)

		jsonName := getJSONFieldName(field)
		if jsonName == "" {
			continue
		}
		genOptions := getCloudEventOptions(field)
		// Skip defined column fields
		if _, ok := CloudeventHeadersToColumnMap[jsonName]; ok {
			continue
		}

		nonColumnFields = append(nonColumnFields, FieldInfo{
			FieldName: field.Name,
			JSONName:  jsonName,
			GoType:    field.Type,
			Kind:      field.Type.Kind().String(),
			Options:   genOptions,
		})
	}

	// Prepare template data
	data := TemplateData{
		NonColumnFields: nonColumnFields,
	}

	// Create template
	tmpl, err := template.New("accessors").Parse(codeTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	// Generate code
	var buff bytes.Buffer

	err = tmpl.Execute(&buff, data)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}
	err = codegen.FormatAndWriteToFile(buff.Bytes(), *outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting and writing to file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated field accessors in %s\n", *outputFile)
}

// getJSONFieldName extracts the JSON field name from a struct field tag
func getJSONFieldName(field reflect.StructField) string {
	tag := field.Tag.Get("json")
	if tag == "" {
		return ""
	}

	name := tag
	if comma := strings.Index(tag, ","); comma != -1 {
		name = tag[:comma]
	}

	if name == "-" {
		return ""
	}

	return name
}

type Options struct {
	// LeaveInExtras indicates that the field should be left in the Extras map.
	LeaveInExtras bool
}

// getCloudEventOptions extracts the CloudEventOptions from a struct field tag
func getCloudEventOptions(field reflect.StructField) Options {
	opts := Options{}
	tag := field.Tag.Get("cloudevent")
	if tag == "" {
		return opts
	}
	optValues := strings.Split(tag, ",")
	for _, opt := range optValues {
		switch opt {
		case "leaveInExtras":
			opts.LeaveInExtras = true
		}
	}
	return opts
}

// Define the template for the generated code
const codeTemplate = `// Code generated by go run pkg/codegen/main.go; DO NOT EDIT.

package clickhouse

import (
	"encoding/json"
	"reflect"
	"time"

	"github.com/DIMO-Network/cloudevent"
)

// RestoreNonColumnFields restores non-column fields from Extras
func RestoreNonColumnFields(event *cloudevent.CloudEventHeader) {
	if event.Extras == nil || len(event.Extras) == 0 {
		return
	}
	{{ range .NonColumnFields -}}
	// Restore {{ .FieldName }} field
	if val, ok := event.Extras["{{ .JSONName }}"]; ok {
		{{ if eq .GoType.String "time.Time" -}}
		// Time needs special handling
		if timeStr, ok := val.(string); ok {
			if t, err := time.Parse(time.RFC3339, timeStr); err == nil {
				event.{{ .FieldName }} = t
				{{ if not .Options.LeaveInExtras -}}
					delete(event.Extras, "{{ .JSONName }}")
				{{ end -}}
			}
		} else if t, ok := val.(time.Time); ok {
			event.{{ .FieldName }} = t
			{{ if not .Options.LeaveInExtras -}}
				delete(event.Extras, "{{ .JSONName }}")
			{{ end -}}
		}
		{{ else if eq .Kind "slice" -}}
		if anySlice, ok := val.([]any); ok {
			typedSlice := make({{ .GoType.String }}, len(anySlice))
			for i, v := range anySlice {
				typedSlice[i] = v.({{ .GoType.Elem.String }})
			}
			event.{{ .FieldName }} = typedSlice
		}
		{{ else -}}
		if typedVal, ok := val.({{ .GoType.String }}); ok {
			event.{{ .FieldName }} = typedVal
		}
		{{ end -}}
		{{ if not .Options.LeaveInExtras -}}
		delete(event.Extras, "{{ .JSONName }}")
		{{ end -}}
	}
	{{ end -}}
}

// AddNonColumnFieldsToExtras adds fields without dedicated columns to Extras
func AddNonColumnFieldsToExtras(event *cloudevent.CloudEventHeader) map[string]any {
	extras := event.Extras
	// Prepare extras map if it's nil
	if extras == nil {
		extras = make(map[string]any)
	} else {
		// Create a copy of extras to avoid modifying the original
		originalExtras := extras
		extras = make(map[string]any, len(originalExtras))
		for k, v := range originalExtras {
			extras[k] = v
		}
	}
	
	{{ range .NonColumnFields -}}
	// Add {{ .FieldName }} to extras if not zeros
	{{ if eq .Kind "string" -}}
	if event.{{ .FieldName }} != "" {
		extras["{{ .JSONName }}"] = event.{{ .FieldName }}
	}
	{{ else if eq .GoType.String "time.Time" -}}
	if !event.{{ .FieldName }}.IsZero() {
		extras["{{ .JSONName }}"] = event.{{ .FieldName }}
	}
	{{ else if eq .Kind "slice" -}}
	if len(event.{{ .FieldName }}) > 0 {
		extras["{{ .JSONName }}"] = event.{{ .FieldName }}
	}
	{{ else -}}
	if !isZeroValue(event.{{ .FieldName }}) {
		extras["{{ .JSONName }}"] = event.{{ .FieldName }}
	}
	{{ end -}}
	{{ end -}}
	return extras
}

// isZeroValue checks if a value is the zero value for its type.
func isZeroValue[T comparable](v T) bool {
	var zero T
	return v == zero
}
`
